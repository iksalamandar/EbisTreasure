{"ast":null,"code":"/**\r\n * CSV Data Loader\r\n * \r\n * This file loads product data from the actual CSV file.\r\n * The CSV data is fetched and parsed using PapaParse library.\r\n * \r\n * Benefits of this approach:\r\n * - Easy to edit product data by modifying the CSV file\r\n * - Can be updated by non-technical users\r\n * - Better for bulk data management\r\n * - Real-time updates when CSV file changes\r\n */\n\nimport Papa from 'papaparse';\n\n// Cache for parsed products to avoid re-parsing\nlet productsCache = null;\n\n/**\r\n * Loads and parses the CSV data from the actual CSV file\r\n * @returns {Promise<Array>} Promise that resolves to array of product objects\r\n */\nconst loadProductsFromCSV = async () => {\n  if (productsCache) {\n    return productsCache;\n  }\n  try {\n    // Fetch CSV data from the file\n    const response = await fetch('/src/data/products.csv');\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV: ${response.status}`);\n    }\n    const csvText = await response.text();\n\n    // Parse CSV data\n    const parseResult = Papa.parse(csvText, {\n      header: true,\n      skipEmptyLines: true,\n      transformHeader: header => header.trim(),\n      transform: (value, field) => {\n        // Convert price to number\n        if (field === 'price') {\n          return parseFloat(value);\n        }\n        return value.trim();\n      }\n    });\n    if (parseResult.errors.length > 0) {\n      console.error('CSV parsing errors:', parseResult.errors);\n    }\n    productsCache = parseResult.data;\n    return productsCache;\n  } catch (error) {\n    console.error('Error loading CSV data:', error);\n    // Fallback to empty array if CSV loading fails\n    return [];\n  }\n};\n\n/**\r\n * Helper function to get products by category\r\n * @param {string} category - The category name ('toys', 'educational', 'sharpening')\r\n * @returns {Promise<Array>} Promise that resolves to array of products for the specified category\r\n */\nexport const getProductsByCategory = async category => {\n  const products = await loadProductsFromCSV();\n  return products.filter(product => product.category === category);\n};\n\n/**\r\n * Helper function to get all products\r\n * @returns {Promise<Array>} Promise that resolves to array of all products across all categories\r\n */\nexport const getAllProducts = async () => {\n  return await loadProductsFromCSV();\n};\n\n/**\r\n * Helper function to get a specific product by ID\r\n * @param {string} id - The product ID\r\n * @returns {Promise<Object|null>} Promise that resolves to the product object or null if not found\r\n */\nexport const getProductById = async id => {\n  const products = await loadProductsFromCSV();\n  return products.find(product => product.id === id) || null;\n};\n\n/**\r\n * Helper function to get products by price range\r\n * @param {number} minPrice - Minimum price\r\n * @param {number} maxPrice - Maximum price\r\n * @returns {Promise<Array>} Promise that resolves to array of products within the price range\r\n */\nexport const getProductsByPriceRange = async (minPrice, maxPrice) => {\n  const products = await loadProductsFromCSV();\n  return products.filter(product => product.price >= minPrice && product.price <= maxPrice);\n};\n\n/**\r\n * Helper function to search products by name or description\r\n * @param {string} searchTerm - The search term\r\n * @returns {Promise<Array>} Promise that resolves to array of matching products\r\n */\nexport const searchProducts = async searchTerm => {\n  const products = await loadProductsFromCSV();\n  const term = searchTerm.toLowerCase();\n  return products.filter(product => product.name.toLowerCase().includes(term) || product.description.toLowerCase().includes(term));\n};\n\n/**\r\n * Helper function to clear the cache (useful for development/testing)\r\n */\nexport const clearCache = () => {\n  productsCache = null;\n};","map":{"version":3,"names":["Papa","productsCache","loadProductsFromCSV","response","fetch","ok","Error","status","csvText","text","parseResult","parse","header","skipEmptyLines","transformHeader","trim","transform","value","field","parseFloat","errors","length","console","error","data","getProductsByCategory","category","products","filter","product","getAllProducts","getProductById","id","find","getProductsByPriceRange","minPrice","maxPrice","price","searchProducts","searchTerm","term","toLowerCase","name","includes","description","clearCache"],"sources":["D:/wEB 1/src/data/csvDataLoader.js"],"sourcesContent":["/**\r\n * CSV Data Loader\r\n * \r\n * This file loads product data from the actual CSV file.\r\n * The CSV data is fetched and parsed using PapaParse library.\r\n * \r\n * Benefits of this approach:\r\n * - Easy to edit product data by modifying the CSV file\r\n * - Can be updated by non-technical users\r\n * - Better for bulk data management\r\n * - Real-time updates when CSV file changes\r\n */\r\n\r\nimport Papa from 'papaparse';\r\n\r\n// Cache for parsed products to avoid re-parsing\r\nlet productsCache = null;\r\n\r\n/**\r\n * Loads and parses the CSV data from the actual CSV file\r\n * @returns {Promise<Array>} Promise that resolves to array of product objects\r\n */\r\nconst loadProductsFromCSV = async () => {\r\n  if (productsCache) {\r\n    return productsCache;\r\n  }\r\n\r\n  try {\r\n    // Fetch CSV data from the file\r\n    const response = await fetch('/src/data/products.csv');\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch CSV: ${response.status}`);\r\n    }\r\n    \r\n    const csvText = await response.text();\r\n    \r\n    // Parse CSV data\r\n    const parseResult = Papa.parse(csvText, {\r\n      header: true,\r\n      skipEmptyLines: true,\r\n      transformHeader: (header) => header.trim(),\r\n      transform: (value, field) => {\r\n        // Convert price to number\r\n        if (field === 'price') {\r\n          return parseFloat(value);\r\n        }\r\n        return value.trim();\r\n      }\r\n    });\r\n\r\n    if (parseResult.errors.length > 0) {\r\n      console.error('CSV parsing errors:', parseResult.errors);\r\n    }\r\n\r\n    productsCache = parseResult.data;\r\n    return productsCache;\r\n  } catch (error) {\r\n    console.error('Error loading CSV data:', error);\r\n    // Fallback to empty array if CSV loading fails\r\n    return [];\r\n  }\r\n};\r\n\r\n/**\r\n * Helper function to get products by category\r\n * @param {string} category - The category name ('toys', 'educational', 'sharpening')\r\n * @returns {Promise<Array>} Promise that resolves to array of products for the specified category\r\n */\r\nexport const getProductsByCategory = async (category) => {\r\n  const products = await loadProductsFromCSV();\r\n  return products.filter(product => product.category === category);\r\n};\r\n\r\n/**\r\n * Helper function to get all products\r\n * @returns {Promise<Array>} Promise that resolves to array of all products across all categories\r\n */\r\nexport const getAllProducts = async () => {\r\n  return await loadProductsFromCSV();\r\n};\r\n\r\n/**\r\n * Helper function to get a specific product by ID\r\n * @param {string} id - The product ID\r\n * @returns {Promise<Object|null>} Promise that resolves to the product object or null if not found\r\n */\r\nexport const getProductById = async (id) => {\r\n  const products = await loadProductsFromCSV();\r\n  return products.find(product => product.id === id) || null;\r\n};\r\n\r\n/**\r\n * Helper function to get products by price range\r\n * @param {number} minPrice - Minimum price\r\n * @param {number} maxPrice - Maximum price\r\n * @returns {Promise<Array>} Promise that resolves to array of products within the price range\r\n */\r\nexport const getProductsByPriceRange = async (minPrice, maxPrice) => {\r\n  const products = await loadProductsFromCSV();\r\n  return products.filter(product => \r\n    product.price >= minPrice && product.price <= maxPrice\r\n  );\r\n};\r\n\r\n/**\r\n * Helper function to search products by name or description\r\n * @param {string} searchTerm - The search term\r\n * @returns {Promise<Array>} Promise that resolves to array of matching products\r\n */\r\nexport const searchProducts = async (searchTerm) => {\r\n  const products = await loadProductsFromCSV();\r\n  const term = searchTerm.toLowerCase();\r\n  return products.filter(product => \r\n    product.name.toLowerCase().includes(term) ||\r\n    product.description.toLowerCase().includes(term)\r\n  );\r\n};\r\n\r\n/**\r\n * Helper function to clear the cache (useful for development/testing)\r\n */\r\nexport const clearCache = () => {\r\n  productsCache = null;\r\n};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,IAAI,MAAM,WAAW;;AAE5B;AACA,IAAIC,aAAa,GAAG,IAAI;;AAExB;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,GAAG,MAAAA,CAAA,KAAY;EACtC,IAAID,aAAa,EAAE;IACjB,OAAOA,aAAa;EACtB;EAEA,IAAI;IACF;IACA,MAAME,QAAQ,GAAG,MAAMC,KAAK,CAAC,wBAAwB,CAAC;IACtD,IAAI,CAACD,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,wBAAwBH,QAAQ,CAACI,MAAM,EAAE,CAAC;IAC5D;IAEA,MAAMC,OAAO,GAAG,MAAML,QAAQ,CAACM,IAAI,CAAC,CAAC;;IAErC;IACA,MAAMC,WAAW,GAAGV,IAAI,CAACW,KAAK,CAACH,OAAO,EAAE;MACtCI,MAAM,EAAE,IAAI;MACZC,cAAc,EAAE,IAAI;MACpBC,eAAe,EAAGF,MAAM,IAAKA,MAAM,CAACG,IAAI,CAAC,CAAC;MAC1CC,SAAS,EAAEA,CAACC,KAAK,EAAEC,KAAK,KAAK;QAC3B;QACA,IAAIA,KAAK,KAAK,OAAO,EAAE;UACrB,OAAOC,UAAU,CAACF,KAAK,CAAC;QAC1B;QACA,OAAOA,KAAK,CAACF,IAAI,CAAC,CAAC;MACrB;IACF,CAAC,CAAC;IAEF,IAAIL,WAAW,CAACU,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;MACjCC,OAAO,CAACC,KAAK,CAAC,qBAAqB,EAAEb,WAAW,CAACU,MAAM,CAAC;IAC1D;IAEAnB,aAAa,GAAGS,WAAW,CAACc,IAAI;IAChC,OAAOvB,aAAa;EACtB,CAAC,CAAC,OAAOsB,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IAC/C;IACA,OAAO,EAAE;EACX;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,qBAAqB,GAAG,MAAOC,QAAQ,IAAK;EACvD,MAAMC,QAAQ,GAAG,MAAMzB,mBAAmB,CAAC,CAAC;EAC5C,OAAOyB,QAAQ,CAACC,MAAM,CAACC,OAAO,IAAIA,OAAO,CAACH,QAAQ,KAAKA,QAAQ,CAAC;AAClE,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMI,cAAc,GAAG,MAAAA,CAAA,KAAY;EACxC,OAAO,MAAM5B,mBAAmB,CAAC,CAAC;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM6B,cAAc,GAAG,MAAOC,EAAE,IAAK;EAC1C,MAAML,QAAQ,GAAG,MAAMzB,mBAAmB,CAAC,CAAC;EAC5C,OAAOyB,QAAQ,CAACM,IAAI,CAACJ,OAAO,IAAIA,OAAO,CAACG,EAAE,KAAKA,EAAE,CAAC,IAAI,IAAI;AAC5D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,uBAAuB,GAAG,MAAAA,CAAOC,QAAQ,EAAEC,QAAQ,KAAK;EACnE,MAAMT,QAAQ,GAAG,MAAMzB,mBAAmB,CAAC,CAAC;EAC5C,OAAOyB,QAAQ,CAACC,MAAM,CAACC,OAAO,IAC5BA,OAAO,CAACQ,KAAK,IAAIF,QAAQ,IAAIN,OAAO,CAACQ,KAAK,IAAID,QAChD,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,cAAc,GAAG,MAAOC,UAAU,IAAK;EAClD,MAAMZ,QAAQ,GAAG,MAAMzB,mBAAmB,CAAC,CAAC;EAC5C,MAAMsC,IAAI,GAAGD,UAAU,CAACE,WAAW,CAAC,CAAC;EACrC,OAAOd,QAAQ,CAACC,MAAM,CAACC,OAAO,IAC5BA,OAAO,CAACa,IAAI,CAACD,WAAW,CAAC,CAAC,CAACE,QAAQ,CAACH,IAAI,CAAC,IACzCX,OAAO,CAACe,WAAW,CAACH,WAAW,CAAC,CAAC,CAACE,QAAQ,CAACH,IAAI,CACjD,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMK,UAAU,GAAGA,CAAA,KAAM;EAC9B5C,aAAa,GAAG,IAAI;AACtB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}